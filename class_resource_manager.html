<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Sleeping Wombat Graphic API: ResourceManager Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Sleeping Wombat Graphic API
   &#160;<span id="projectnumber">1.010</span>
   </div>
   <div id="projectbrief">swGraphicAPI</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="class_resource_manager-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ResourceManager Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Manager for low level resources.  
 <a href="class_resource_manager.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_resource_manager_8h_source.html">ResourceManager.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4a00d9a302bf876e5da170ef13385e53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_render_target_object.html">RenderTargetObject</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_resource_manager.html#a4a00d9a302bf876e5da170ef13385e53">CreateRenderTarget</a> (const std::wstring &amp;name, const <a class="el" href="struct_render_target_descriptor.html">RenderTargetDescriptor</a> &amp;renderTargetDescriptor)</td></tr>
<tr class="memdesc:a4a00d9a302bf876e5da170ef13385e53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Znajduje Loader pasujący do pliku podanego w parametrze.  <a href="#a4a00d9a302bf876e5da170ef13385e53">More...</a><br /></td></tr>
<tr class="separator:a4a00d9a302bf876e5da170ef13385e53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d4f0b23fa0b0de46a8d28fff79eb318"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_render_target_object.html">RenderTargetObject</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_resource_manager.html#a6d4f0b23fa0b0de46a8d28fff79eb318">AddRenderTarget</a> (<a class="el" href="class_render_target_object.html">RenderTargetObject</a> *renderTarget, const std::wstring &amp;name)</td></tr>
<tr class="memdesc:a6d4f0b23fa0b0de46a8d28fff79eb318"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dodaje renderTarget do ResourceManagera, jeżeli jeszcze nie istniał.  <a href="#a6d4f0b23fa0b0de46a8d28fff79eb318">More...</a><br /></td></tr>
<tr class="separator:a6d4f0b23fa0b0de46a8d28fff79eb318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Geting existing resource</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Gets resource if exist otherwise returns nullptr. </p>
</div></td></tr>
<tr class="memitem:adcffb170252d32748cd8b21c45a894e5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adcffb170252d32748cd8b21c45a894e5"></a>
<a class="el" href="class_blending_state.html">BlendingState</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>GetBlendingState</b> (const std::wstring &amp;name)</td></tr>
<tr class="separator:adcffb170252d32748cd8b21c45a894e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03c03a352158e5671249e0f58e81ba7e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a03c03a352158e5671249e0f58e81ba7e"></a>
<a class="el" href="class_rasterizer_state.html">RasterizerState</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>GetRasterizerState</b> (const std::wstring &amp;name)</td></tr>
<tr class="separator:a03c03a352158e5671249e0f58e81ba7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8edae9d08d694de857221d4137460175"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8edae9d08d694de857221d4137460175"></a>
<a class="el" href="class_depth_stencil_state.html">DepthStencilState</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>GetDepthStencilState</b> (const std::wstring &amp;name)</td></tr>
<tr class="separator:a8edae9d08d694de857221d4137460175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b08986aff83d3c41c48564a806eaf51"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1b08986aff83d3c41c48564a806eaf51"></a>
<a class="el" href="class_blending_state.html">BlendingState</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>GetBlendingState</b> (const <a class="el" href="struct_blending_info.html">BlendingInfo</a> &amp;info)</td></tr>
<tr class="separator:a1b08986aff83d3c41c48564a806eaf51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbbb3f3f4c2789a98778e0888afbbb3f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afbbb3f3f4c2789a98778e0888afbbb3f"></a>
<a class="el" href="class_rasterizer_state.html">RasterizerState</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>GetRasterizerState</b> (const <a class="el" href="struct_rasterizer_state_info.html">RasterizerStateInfo</a> &amp;info)</td></tr>
<tr class="separator:afbbb3f3f4c2789a98778e0888afbbb3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80fa37818eb016443a5ca56ccefd9f7d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a80fa37818eb016443a5ca56ccefd9f7d"></a>
<a class="el" href="class_depth_stencil_state.html">DepthStencilState</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>GetDepthStencilState</b> (const <a class="el" href="struct_depth_stencil_info.html">DepthStencilInfo</a> &amp;info)</td></tr>
<tr class="separator:a80fa37818eb016443a5ca56ccefd9f7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e09c7acd359431076af06d466f26016"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6e09c7acd359431076af06d466f26016"></a>
<a class="el" href="class_render_target_object.html">RenderTargetObject</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_resource_manager.html#a6e09c7acd359431076af06d466f26016">GetRenderTarget</a> (const std::wstring &amp;name)</td></tr>
<tr class="memdesc:a6e09c7acd359431076af06d466f26016"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zwraca RenderTarget o podanej nazwie, jeżeli jest wczytany. <br /></td></tr>
<tr class="separator:a6e09c7acd359431076af06d466f26016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a222fa0ab8f64b5e3bcc78df8ae471baf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a222fa0ab8f64b5e3bcc78df8ae471baf"></a>
<a class="el" href="class_vertex_shader.html">VertexShader</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_resource_manager.html#a222fa0ab8f64b5e3bcc78df8ae471baf">GetVertexShader</a> (const std::wstring &amp;name)</td></tr>
<tr class="memdesc:a222fa0ab8f64b5e3bcc78df8ae471baf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zwraca vertex shader o podanej nazwie, jeżeli jest wczytany. <br /></td></tr>
<tr class="separator:a222fa0ab8f64b5e3bcc78df8ae471baf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace1eebc1a488546e415da5a84a4b0a3d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace1eebc1a488546e415da5a84a4b0a3d"></a>
<a class="el" href="class_pixel_shader.html">PixelShader</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_resource_manager.html#ace1eebc1a488546e415da5a84a4b0a3d">GetPixelShader</a> (const std::wstring &amp;name)</td></tr>
<tr class="memdesc:ace1eebc1a488546e415da5a84a4b0a3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zwraca pixel shader o podanej nazwie, jeżeli jest wczytany. <br /></td></tr>
<tr class="separator:ace1eebc1a488546e415da5a84a4b0a3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15e5b0e38aaa1903884c6fedb80c4a7d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a15e5b0e38aaa1903884c6fedb80c4a7d"></a>
<a class="el" href="class_texture_object.html">TextureObject</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_resource_manager.html#a15e5b0e38aaa1903884c6fedb80c4a7d">GetTexture</a> (const std::wstring &amp;name)</td></tr>
<tr class="memdesc:a15e5b0e38aaa1903884c6fedb80c4a7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zwraca teksturę o podanej nazwie, jeżeli jest wczytany. <br /></td></tr>
<tr class="separator:a15e5b0e38aaa1903884c6fedb80c4a7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c0647b8d4f67887d2b090da2c0250db"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4c0647b8d4f67887d2b090da2c0250db"></a>
<a class="el" href="class_buffer_object.html">BufferObject</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_resource_manager.html#a4c0647b8d4f67887d2b090da2c0250db">GetVertexBuffer</a> (const std::wstring &amp;name)</td></tr>
<tr class="memdesc:a4c0647b8d4f67887d2b090da2c0250db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zwraca bufor wierzchołków o podanej nazwie, jeżeli jest wczytany. <br /></td></tr>
<tr class="separator:a4c0647b8d4f67887d2b090da2c0250db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1983d7d1f1d41074cf974c23a0f569e3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1983d7d1f1d41074cf974c23a0f569e3"></a>
<a class="el" href="class_buffer_object.html">BufferObject</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_resource_manager.html#a1983d7d1f1d41074cf974c23a0f569e3">GetConstantBuffer</a> (const std::wstring &amp;name)</td></tr>
<tr class="memdesc:a1983d7d1f1d41074cf974c23a0f569e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zwraca bufor stałych o podanej nazwie, jeżeli jest wczytany. <br /></td></tr>
<tr class="separator:a1983d7d1f1d41074cf974c23a0f569e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a964d3d93cf9185c4c674593c696e32a2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a964d3d93cf9185c4c674593c696e32a2"></a>
<a class="el" href="class_buffer_object.html">BufferObject</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_resource_manager.html#a964d3d93cf9185c4c674593c696e32a2">GetIndexBuffer</a> (const std::wstring &amp;name)</td></tr>
<tr class="memdesc:a964d3d93cf9185c4c674593c696e32a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zwraca bufor indeksów o podanej nazwie, jeżeli jest wczytany. <br /></td></tr>
<tr class="separator:a964d3d93cf9185c4c674593c696e32a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fc1190ef3eaad6f3fcfd3bf5b9c16e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_shader_input_layout.html">ShaderInputLayout</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_resource_manager.html#a5fc1190ef3eaad6f3fcfd3bf5b9c16e6">GetLayout</a> (const std::wstring &amp;name)</td></tr>
<tr class="separator:a5fc1190ef3eaad6f3fcfd3bf5b9c16e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Resource loading</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Load assets from specified file. Functions protect from loading assets multiple times. </p>
</div></td></tr>
<tr class="memitem:ad7dcc47c454a2fc26a8b749ad54383ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_texture_object.html">TextureObject</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_resource_manager.html#ad7dcc47c454a2fc26a8b749ad54383ce">LoadTexture</a> (const std::wstring &amp;fileName)</td></tr>
<tr class="memdesc:ad7dcc47c454a2fc26a8b749ad54383ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dodaje teksturę do ModelManagera, jeżeli jeszcze nie istniała.  <a href="#ad7dcc47c454a2fc26a8b749ad54383ce">More...</a><br /></td></tr>
<tr class="separator:ad7dcc47c454a2fc26a8b749ad54383ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a2453870e7f70bc30bb0adf894fb4bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_vertex_shader.html">VertexShader</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_resource_manager.html#a9a2453870e7f70bc30bb0adf894fb4bb">LoadVertexShader</a> (const std::wstring &amp;fileName, const std::string &amp;shaderEntry)</td></tr>
<tr class="memdesc:a9a2453870e7f70bc30bb0adf894fb4bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dodaje vertex shader do ResourceManagera. Jeżeli obiekt już istniał, to nie jest tworzony nowy.  <a href="#a9a2453870e7f70bc30bb0adf894fb4bb">More...</a><br /></td></tr>
<tr class="separator:a9a2453870e7f70bc30bb0adf894fb4bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19e57a77cdcdb9dd34412ec5de7bd8ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_vertex_shader.html">VertexShader</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_resource_manager.html#a19e57a77cdcdb9dd34412ec5de7bd8ac">LoadVertexShader</a> (const std::wstring &amp;fileName, const std::string &amp;shaderEntry, <a class="el" href="class_shader_input_layout.html">ShaderInputLayout</a> **layout, <a class="el" href="class_input_layout_descriptor.html">InputLayoutDescriptor</a> *layout_desc)</td></tr>
<tr class="memdesc:a19e57a77cdcdb9dd34412ec5de7bd8ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dodaje vertex shader do ResourceManagera. Jeżeli obiekt już istniał, to nie jest tworzony nowy. Tworzy też layout wierzchołka związany z tym shaderem i zwraca go w zmiennej layout.  <a href="#a19e57a77cdcdb9dd34412ec5de7bd8ac">More...</a><br /></td></tr>
<tr class="separator:a19e57a77cdcdb9dd34412ec5de7bd8ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2977707a7db0d1f8fde88af7dd929ed0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pixel_shader.html">PixelShader</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_resource_manager.html#a2977707a7db0d1f8fde88af7dd929ed0">LoadPixelShader</a> (const std::wstring &amp;fileName, const std::string &amp;shaderEntry)</td></tr>
<tr class="memdesc:a2977707a7db0d1f8fde88af7dd929ed0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dodaje pixel shader do ResourceManagera. Jeżeli obiekt już istniał, to nie jest tworzony nowy.  <a href="#a2977707a7db0d1f8fde88af7dd929ed0">More...</a><br /></td></tr>
<tr class="separator:a2977707a7db0d1f8fde88af7dd929ed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfbd6f74d74b5f4a768719f7fe8a25b6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abfbd6f74d74b5f4a768719f7fe8a25b6"></a>
<a class="el" href="class_geometry_shader.html">GeometryShader</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>LoadGeometryShader</b> (const std::wstring &amp;fileName, const std::string &amp;shaderEntry)</td></tr>
<tr class="separator:abfbd6f74d74b5f4a768719f7fe8a25b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46cd94180a92f4c29633a4e67c24fc38"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a46cd94180a92f4c29633a4e67c24fc38"></a>
<a class="el" href="class_control_shader.html">ControlShader</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>LoadControlShader</b> (const std::wstring &amp;fileName, const std::string &amp;shaderEntry)</td></tr>
<tr class="separator:a46cd94180a92f4c29633a4e67c24fc38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d10b2e2559a70f6fc7d0893d9384538"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d10b2e2559a70f6fc7d0893d9384538"></a>
<a class="el" href="class_evaluation_shader.html">EvaluationShader</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>LoadEvaluationShader</b> (const std::wstring &amp;fileName, const std::string &amp;shaderEntry)</td></tr>
<tr class="separator:a3d10b2e2559a70f6fc7d0893d9384538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Resource creation</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>You can create assets in code using these functions. Remember to give unique names for your assets. Engine uses convention, that all generated resources have :: before name, to distinguish them from assets loaded from files. </p>
</div></td></tr>
<tr class="memitem:afd23a950d995a07a6bcc5ca64bfc860d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_resource_ptr.html">ResourcePtr</a>&lt; <a class="el" href="class_buffer_object.html">BufferObject</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_resource_manager.html#afd23a950d995a07a6bcc5ca64bfc860d">CreateVertexBuffer</a> (const std::wstring &amp;name, const void *buffer, unsigned int element_size, unsigned int vert_count)</td></tr>
<tr class="memdesc:afd23a950d995a07a6bcc5ca64bfc860d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dodaje do ResourceManagera bufor wierzchołków. Jeżeli pod taką nazwą istnieje jakiś bufor, to zostanie zwrócony wskaźnik na niego.  <a href="#afd23a950d995a07a6bcc5ca64bfc860d">More...</a><br /></td></tr>
<tr class="separator:afd23a950d995a07a6bcc5ca64bfc860d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a851ebe7c00ed3837dbf83d4c195be1a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_resource_ptr.html">ResourcePtr</a>&lt; <a class="el" href="class_buffer_object.html">BufferObject</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_resource_manager.html#a851ebe7c00ed3837dbf83d4c195be1a6">CreateVertexBuffer</a> (const std::wstring &amp;name, const <a class="el" href="struct_vertex_buffer_init_data.html">VertexBufferInitData</a> &amp;data)</td></tr>
<tr class="memdesc:a851ebe7c00ed3837dbf83d4c195be1a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates vetex buffer.  <a href="#a851ebe7c00ed3837dbf83d4c195be1a6">More...</a><br /></td></tr>
<tr class="separator:a851ebe7c00ed3837dbf83d4c195be1a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00341729422730d9560abc9b7c6f63ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_resource_ptr.html">ResourcePtr</a>&lt; <a class="el" href="class_buffer_object.html">BufferObject</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_resource_manager.html#a00341729422730d9560abc9b7c6f63ec">CreateIndexBuffer</a> (const std::wstring &amp;name, const void *buffer, unsigned int element_size, unsigned int vert_count)</td></tr>
<tr class="memdesc:a00341729422730d9560abc9b7c6f63ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dodaje do ResourceManagera bufor indeksów. Jeżeli pod taką nazwą istnieje jakiś bufor, to zostanie zwrócony wskaźnik na niego.  <a href="#a00341729422730d9560abc9b7c6f63ec">More...</a><br /></td></tr>
<tr class="separator:a00341729422730d9560abc9b7c6f63ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af311328699c5d0d8862703a372dda584"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_resource_ptr.html">ResourcePtr</a>&lt; <a class="el" href="class_buffer_object.html">BufferObject</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_resource_manager.html#af311328699c5d0d8862703a372dda584">CreateIndexBuffer</a> (const std::wstring &amp;name, const <a class="el" href="struct_index_buffer_init_data.html">IndexBufferInitData</a> &amp;data)</td></tr>
<tr class="memdesc:af311328699c5d0d8862703a372dda584"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vreates index buffer.  <a href="#af311328699c5d0d8862703a372dda584">More...</a><br /></td></tr>
<tr class="separator:af311328699c5d0d8862703a372dda584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1e2a00f687397ba7716d8bd0e51127f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_resource_ptr.html">ResourcePtr</a>&lt; <a class="el" href="class_buffer_object.html">BufferObject</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_resource_manager.html#ab1e2a00f687397ba7716d8bd0e51127f">CreateConstantsBuffer</a> (const std::wstring &amp;name, const void *buffer, unsigned int size)</td></tr>
<tr class="memdesc:ab1e2a00f687397ba7716d8bd0e51127f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dodaje do ResourceManagera bufor stałch dla shadera. Jeżeli pod taką nazwą istnieje jakiś bufor, to zostanie zwrócony wskaźnik na niego.  <a href="#ab1e2a00f687397ba7716d8bd0e51127f">More...</a><br /></td></tr>
<tr class="separator:ab1e2a00f687397ba7716d8bd0e51127f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee48f8c03cbc64d10072c49d498a33af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_resource_ptr.html">ResourcePtr</a>&lt; <a class="el" href="class_buffer_object.html">BufferObject</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_resource_manager.html#aee48f8c03cbc64d10072c49d498a33af">CreateConstantsBuffer</a> (const std::wstring &amp;name, const <a class="el" href="struct_constant_buffer_init_data.html">ConstantBufferInitData</a> &amp;data)</td></tr>
<tr class="memdesc:aee48f8c03cbc64d10072c49d498a33af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates constant buffer.  <a href="#aee48f8c03cbc64d10072c49d498a33af">More...</a><br /></td></tr>
<tr class="separator:aee48f8c03cbc64d10072c49d498a33af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab964a55a5383da42a150d17aded9c07d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_resource_ptr.html">ResourcePtr</a>&lt; <a class="el" href="class_blending_state.html">BlendingState</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_resource_manager.html#ab964a55a5383da42a150d17aded9c07d">CreateBlendingState</a> (const std::wstring &amp;name, const <a class="el" href="struct_blending_info.html">BlendingInfo</a> &amp;info)</td></tr>
<tr class="memdesc:ab964a55a5383da42a150d17aded9c07d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Created <a class="el" href="class_blending_state.html">BlendingState</a> object.  <a href="#ab964a55a5383da42a150d17aded9c07d">More...</a><br /></td></tr>
<tr class="separator:ab964a55a5383da42a150d17aded9c07d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa318476801d2b5a1adbe130d6cd40817"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_resource_ptr.html">ResourcePtr</a>&lt; <a class="el" href="class_rasterizer_state.html">RasterizerState</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_resource_manager.html#aa318476801d2b5a1adbe130d6cd40817">CreateRasterizerState</a> (const std::wstring &amp;name, const <a class="el" href="struct_rasterizer_state_info.html">RasterizerStateInfo</a> &amp;info)</td></tr>
<tr class="memdesc:aa318476801d2b5a1adbe130d6cd40817"><td class="mdescLeft">&#160;</td><td class="mdescRight">Created <a class="el" href="class_rasterizer_state.html" title="Rasterizer state and depth stencil state. ">RasterizerState</a> object.  <a href="#aa318476801d2b5a1adbe130d6cd40817">More...</a><br /></td></tr>
<tr class="separator:aa318476801d2b5a1adbe130d6cd40817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa98fb2ab5bab0a6c6c1f20f5edd0d8cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_resource_ptr.html">ResourcePtr</a>&lt; <a class="el" href="class_depth_stencil_state.html">DepthStencilState</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_resource_manager.html#aa98fb2ab5bab0a6c6c1f20f5edd0d8cb">CreateDepthStencilState</a> (const std::wstring &amp;name, const <a class="el" href="struct_depth_stencil_info.html">DepthStencilInfo</a> &amp;info)</td></tr>
<tr class="memdesc:aa98fb2ab5bab0a6c6c1f20f5edd0d8cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Created <a class="el" href="class_depth_stencil_state.html">DepthStencilState</a> object.  <a href="#aa98fb2ab5bab0a6c6c1f20f5edd0d8cb">More...</a><br /></td></tr>
<tr class="separator:aa98fb2ab5bab0a6c6c1f20f5edd0d8cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Listing resources</div></td></tr>
<tr class="memitem:a7f001790be854ea3d0b850d12ef15e87"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7f001790be854ea3d0b850d12ef15e87"></a>
std::vector&lt; <a class="el" href="class_resource_ptr.html">ResourcePtr</a>&lt; <a class="el" href="class_buffer_object.html">BufferObject</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_resource_manager.html#a7f001790be854ea3d0b850d12ef15e87">ListVertexBuffers</a> ()</td></tr>
<tr class="memdesc:a7f001790be854ea3d0b850d12ef15e87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Listowanie buforów wierzchołków. <br /></td></tr>
<tr class="separator:a7f001790be854ea3d0b850d12ef15e87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8e11d51c4c3a77d2c6ea8ec0ed02320"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad8e11d51c4c3a77d2c6ea8ec0ed02320"></a>
std::vector&lt; <a class="el" href="class_resource_ptr.html">ResourcePtr</a>&lt; <a class="el" href="class_buffer_object.html">BufferObject</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_resource_manager.html#ad8e11d51c4c3a77d2c6ea8ec0ed02320">ListIndexBuffers</a> ()</td></tr>
<tr class="memdesc:ad8e11d51c4c3a77d2c6ea8ec0ed02320"><td class="mdescLeft">&#160;</td><td class="mdescRight">Listowanie buforów indeksów. <br /></td></tr>
<tr class="separator:ad8e11d51c4c3a77d2c6ea8ec0ed02320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07fef77be4fc9bead38fe574794c134c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a07fef77be4fc9bead38fe574794c134c"></a>
std::vector&lt; <a class="el" href="class_resource_ptr.html">ResourcePtr</a>&lt; <a class="el" href="class_buffer_object.html">BufferObject</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_resource_manager.html#a07fef77be4fc9bead38fe574794c134c">ListConstantBuffers</a> ()</td></tr>
<tr class="memdesc:a07fef77be4fc9bead38fe574794c134c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Listowanie buforów stałych. <br /></td></tr>
<tr class="separator:a07fef77be4fc9bead38fe574794c134c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af178f3b3bee8990ed588aa2d17514d9f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af178f3b3bee8990ed588aa2d17514d9f"></a>
std::vector&lt; <a class="el" href="class_resource_ptr.html">ResourcePtr</a>&lt; <a class="el" href="class_shader_input_layout.html">ShaderInputLayout</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_resource_manager.html#af178f3b3bee8990ed588aa2d17514d9f">ListShaderLayouts</a> ()</td></tr>
<tr class="memdesc:af178f3b3bee8990ed588aa2d17514d9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Listowanie layoutów wierzchołków. <br /></td></tr>
<tr class="separator:af178f3b3bee8990ed588aa2d17514d9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7768cad282cb1a934d460c3faa48ef36"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7768cad282cb1a934d460c3faa48ef36"></a>
std::vector&lt; <a class="el" href="class_resource_ptr.html">ResourcePtr</a>&lt; <a class="el" href="class_texture_object.html">TextureObject</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_resource_manager.html#a7768cad282cb1a934d460c3faa48ef36">ListTextures</a> ()</td></tr>
<tr class="memdesc:a7768cad282cb1a934d460c3faa48ef36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Listowanie tekstur. <br /></td></tr>
<tr class="separator:a7768cad282cb1a934d460c3faa48ef36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb8410e22274767bb4eb1594e8d2b7ad"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afb8410e22274767bb4eb1594e8d2b7ad"></a>
std::vector&lt; <a class="el" href="class_resource_ptr.html">ResourcePtr</a>&lt; <a class="el" href="class_vertex_shader.html">VertexShader</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_resource_manager.html#afb8410e22274767bb4eb1594e8d2b7ad">ListVertexShaders</a> ()</td></tr>
<tr class="memdesc:afb8410e22274767bb4eb1594e8d2b7ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Listowanie vertex shaderów. <br /></td></tr>
<tr class="separator:afb8410e22274767bb4eb1594e8d2b7ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c3c7e01db8682c0883848844e1a79d8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6c3c7e01db8682c0883848844e1a79d8"></a>
std::vector&lt; <a class="el" href="class_resource_ptr.html">ResourcePtr</a>&lt; <a class="el" href="class_pixel_shader.html">PixelShader</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_resource_manager.html#a6c3c7e01db8682c0883848844e1a79d8">ListPixelShaders</a> ()</td></tr>
<tr class="memdesc:a6c3c7e01db8682c0883848844e1a79d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Listowanie pixel shaderów. <br /></td></tr>
<tr class="separator:a6c3c7e01db8682c0883848844e1a79d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac89184fe44cdd03951585347a37fd28f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac89184fe44cdd03951585347a37fd28f"></a>
std::vector&lt; <a class="el" href="class_resource_ptr.html">ResourcePtr</a>&lt; <a class="el" href="class_render_target_object.html">RenderTargetObject</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_resource_manager.html#ac89184fe44cdd03951585347a37fd28f">ListRenderTargets</a> ()</td></tr>
<tr class="memdesc:ac89184fe44cdd03951585347a37fd28f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Listowanie render targetów. <br /></td></tr>
<tr class="separator:ac89184fe44cdd03951585347a37fd28f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a2aa0a5a6e976ebacdb32ae918950b52c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2aa0a5a6e976ebacdb32ae918950b52c"></a>
<a class="el" href="class_resource_container.html">ResourceContainer</a>&lt; <a class="el" href="class_blending_state.html">BlendingState</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_resource_manager.html#a2aa0a5a6e976ebacdb32ae918950b52c">m_blendingState</a></td></tr>
<tr class="memdesc:a2aa0a5a6e976ebacdb32ae918950b52c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_blending_state.html">BlendingState</a> objects. <br /></td></tr>
<tr class="separator:a2aa0a5a6e976ebacdb32ae918950b52c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d059a1f86390bfb181e7ffb45758cfa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2d059a1f86390bfb181e7ffb45758cfa"></a>
<a class="el" href="class_resource_container.html">ResourceContainer</a>&lt; <a class="el" href="class_rasterizer_state.html">RasterizerState</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_resource_manager.html#a2d059a1f86390bfb181e7ffb45758cfa">m_rasterizerState</a></td></tr>
<tr class="memdesc:a2d059a1f86390bfb181e7ffb45758cfa"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_rasterizer_state.html" title="Rasterizer state and depth stencil state. ">RasterizerState</a> objects. <br /></td></tr>
<tr class="separator:a2d059a1f86390bfb181e7ffb45758cfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf1c8356d7a228f112e763403eb15601"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acf1c8356d7a228f112e763403eb15601"></a>
<a class="el" href="class_resource_container.html">ResourceContainer</a>&lt; <a class="el" href="class_depth_stencil_state.html">DepthStencilState</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_resource_manager.html#acf1c8356d7a228f112e763403eb15601">m_depthStencilState</a></td></tr>
<tr class="memdesc:acf1c8356d7a228f112e763403eb15601"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_depth_stencil_state.html">DepthStencilState</a> objects. <br /></td></tr>
<tr class="separator:acf1c8356d7a228f112e763403eb15601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08247fbda2e6de1d92f9931fb6df2a27"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a08247fbda2e6de1d92f9931fb6df2a27"></a>
<a class="el" href="class_resource_container.html">ResourceContainer</a>&lt; <a class="el" href="class_vertex_shader.html">VertexShader</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_resource_manager.html#a08247fbda2e6de1d92f9931fb6df2a27">m_vertexShader</a></td></tr>
<tr class="memdesc:a08247fbda2e6de1d92f9931fb6df2a27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vertex shaders. <br /></td></tr>
<tr class="separator:a08247fbda2e6de1d92f9931fb6df2a27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42ca7925418ab678f42a4944ec77db07"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a42ca7925418ab678f42a4944ec77db07"></a>
<a class="el" href="class_resource_container.html">ResourceContainer</a>&lt; <a class="el" href="class_pixel_shader.html">PixelShader</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_resource_manager.html#a42ca7925418ab678f42a4944ec77db07">m_pixelShader</a></td></tr>
<tr class="memdesc:a42ca7925418ab678f42a4944ec77db07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pixel shaders. <br /></td></tr>
<tr class="separator:a42ca7925418ab678f42a4944ec77db07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78161c345ddfcc24b0d863ed1e52fd6c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a78161c345ddfcc24b0d863ed1e52fd6c"></a>
<a class="el" href="class_resource_container.html">ResourceContainer</a>&lt; <a class="el" href="class_geometry_shader.html">GeometryShader</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_resource_manager.html#a78161c345ddfcc24b0d863ed1e52fd6c">m_geometryShader</a></td></tr>
<tr class="memdesc:a78161c345ddfcc24b0d863ed1e52fd6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Geometry shaders. <br /></td></tr>
<tr class="separator:a78161c345ddfcc24b0d863ed1e52fd6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55d16c10f638cb9570c0639ea07f4be0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a55d16c10f638cb9570c0639ea07f4be0"></a>
<a class="el" href="class_resource_container.html">ResourceContainer</a>&lt; <a class="el" href="class_evaluation_shader.html">EvaluationShader</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_resource_manager.html#a55d16c10f638cb9570c0639ea07f4be0">m_evaluationShader</a></td></tr>
<tr class="memdesc:a55d16c10f638cb9570c0639ea07f4be0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tesselation evaluation shaders. <br /></td></tr>
<tr class="separator:a55d16c10f638cb9570c0639ea07f4be0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6210435eb925335878d9e62b2802e380"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6210435eb925335878d9e62b2802e380"></a>
<a class="el" href="class_resource_container.html">ResourceContainer</a>&lt; <a class="el" href="class_control_shader.html">ControlShader</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_resource_manager.html#a6210435eb925335878d9e62b2802e380">m_controlShaders</a></td></tr>
<tr class="memdesc:a6210435eb925335878d9e62b2802e380"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tesselation control shaders. <br /></td></tr>
<tr class="separator:a6210435eb925335878d9e62b2802e380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeed895fdbd4d050b33f31f1e256839aa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeed895fdbd4d050b33f31f1e256839aa"></a>
<a class="el" href="class_resource_container.html">ResourceContainer</a>&lt; <a class="el" href="class_texture_object.html">TextureObject</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_resource_manager.html#aeed895fdbd4d050b33f31f1e256839aa">m_texture</a></td></tr>
<tr class="memdesc:aeed895fdbd4d050b33f31f1e256839aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Textures. <br /></td></tr>
<tr class="separator:aeed895fdbd4d050b33f31f1e256839aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeebcc47e2aec50127ecc7dfad5beaef"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abeebcc47e2aec50127ecc7dfad5beaef"></a>
<a class="el" href="class_resource_container.html">ResourceContainer</a>&lt; <a class="el" href="class_buffer_object.html">BufferObject</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_resource_manager.html#abeebcc47e2aec50127ecc7dfad5beaef">m_vertexBuffer</a></td></tr>
<tr class="memdesc:abeebcc47e2aec50127ecc7dfad5beaef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vertex buffers. <br /></td></tr>
<tr class="separator:abeebcc47e2aec50127ecc7dfad5beaef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86959ebb7419f96b3c44a89bc0dc9fc0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a86959ebb7419f96b3c44a89bc0dc9fc0"></a>
<a class="el" href="class_resource_container.html">ResourceContainer</a>&lt; <a class="el" href="class_buffer_object.html">BufferObject</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_resource_manager.html#a86959ebb7419f96b3c44a89bc0dc9fc0">m_indexBuffer</a></td></tr>
<tr class="memdesc:a86959ebb7419f96b3c44a89bc0dc9fc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index buffers. <br /></td></tr>
<tr class="separator:a86959ebb7419f96b3c44a89bc0dc9fc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a379826d33e2d6b4417977b08002bc405"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a379826d33e2d6b4417977b08002bc405"></a>
<a class="el" href="class_resource_container.html">ResourceContainer</a>&lt; <a class="el" href="class_buffer_object.html">BufferObject</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_resource_manager.html#a379826d33e2d6b4417977b08002bc405">m_constantBuffer</a></td></tr>
<tr class="memdesc:a379826d33e2d6b4417977b08002bc405"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shader constant buffers. <br /></td></tr>
<tr class="separator:a379826d33e2d6b4417977b08002bc405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d915cef525d81139a9c7baa73eb44f6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d915cef525d81139a9c7baa73eb44f6"></a>
<a class="el" href="class_resource_container.html">ResourceContainer</a>&lt; <a class="el" href="class_shader_input_layout.html">ShaderInputLayout</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_resource_manager.html#a9d915cef525d81139a9c7baa73eb44f6">m_vertexLayout</a></td></tr>
<tr class="memdesc:a9d915cef525d81139a9c7baa73eb44f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vertex layouts. <br /></td></tr>
<tr class="separator:a9d915cef525d81139a9c7baa73eb44f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6fe9eac2b9dc8ff82dd2555fb77a4da"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac6fe9eac2b9dc8ff82dd2555fb77a4da"></a>
<a class="el" href="class_resource_container.html">ResourceContainer</a>&lt; <a class="el" href="class_render_target_object.html">RenderTargetObject</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_resource_manager.html#ac6fe9eac2b9dc8ff82dd2555fb77a4da">m_renderTarget</a></td></tr>
<tr class="memdesc:ac6fe9eac2b9dc8ff82dd2555fb77a4da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obiekty mogące służyć za render target. <br /></td></tr>
<tr class="separator:ac6fe9eac2b9dc8ff82dd2555fb77a4da"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a371fca72b205d0b92476275862712cad"><td class="memItemLeft" align="right" valign="top">virtual MemoryChunk&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_resource_manager.html#a371fca72b205d0b92476275862712cad">LoadTextureImpl</a> (const filesystem::Path &amp;filePath, <a class="el" href="struct_texture_info.html">TextureInfo</a> &amp;texInfo)</td></tr>
<tr class="memdesc:a371fca72b205d0b92476275862712cad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of texture loading.  <a href="#a371fca72b205d0b92476275862712cad">More...</a><br /></td></tr>
<tr class="separator:a371fca72b205d0b92476275862712cad"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Manager for low level resources. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000011">Todo:</a></b></dt><dd>This class should implement generic high level asssets managment.</dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a6d4f0b23fa0b0de46a8d28fff79eb318"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_render_target_object.html">RenderTargetObject</a> * ResourceManager::AddRenderTarget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_render_target_object.html">RenderTargetObject</a> *&#160;</td>
          <td class="paramname"><em>renderTarget</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::wstring &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dodaje renderTarget do ResourceManagera, jeżeli jeszcze nie istniał. </p>
<dl class="section note"><dt>Note</dt><dd>Funkcja nie dodaje odwołania do obiektu, bo nie zakłada, że ktoś go od razu użyje. W każdym miejscu, gdzie zostanie przypisany zwrócony obiekt, należy pamiętać o dodaniu odwołania oraz skasowaniu go, gdy obiekt przestanie być używany.</dd>
<dd>
Jeżeli renderTarget już istniał (jego nazwa), to ten podany w parametrze nie zostanie dodany. Oznacza to, że za jego zwolnienie odpowiada ten, kto go stworzył. Trzeba zawsze sprawdzić czy zwrócona wartość jest tym samym co podaliśmy.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000009">Todo:</a></b></dt><dd>Nie może tak zostać, że ktoś dodaje renderTarget i musi sprawdzić czy nie dostał innego. Nie można też zmuszać kogoś do zwalniania pamięci po renderTargecie. Wogóle dodawanie renderTargetów musi się odbywać jakoś inaczej. Najlepiej, żeby były one tworzone przez <a class="el" href="class_resource_manager.html" title="Manager for low level resources. ">ResourceManager</a>, ale wtedy trzeba wymyśleć sposób dodawania renderTargetu związanego z buforem okna.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">renderTarget</td><td>renderTarget, który ma zostać dodany. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Nazwa renderTargetu. Do materiału będzie można się odwołać podając ciąg znaków </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zwraca wskaźnik na dodany renderTarget. </dd></dl>

</div>
</div>
<a class="anchor" id="ab964a55a5383da42a150d17aded9c07d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_resource_ptr.html">ResourcePtr</a>&lt; <a class="el" href="class_blending_state.html">BlendingState</a> &gt; ResourceManager::CreateBlendingState </td>
          <td>(</td>
          <td class="paramtype">const std::wstring &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_blending_info.html">BlendingInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Created <a class="el" href="class_blending_state.html">BlendingState</a> object. </p>
<dl class="section return"><dt>Returns</dt><dd>If object named name exist, returns nullptr. </dd></dl>

</div>
</div>
<a class="anchor" id="ab1e2a00f687397ba7716d8bd0e51127f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_resource_ptr.html">ResourcePtr</a>&lt; <a class="el" href="class_buffer_object.html">BufferObject</a> &gt; ResourceManager::CreateConstantsBuffer </td>
          <td>(</td>
          <td class="paramtype">const std::wstring &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dodaje do ResourceManagera bufor stałch dla shadera. Jeżeli pod taką nazwą istnieje jakiś bufor, to zostanie zwrócony wskaźnik na niego. </p>
<dl class="section note"><dt>Note</dt><dd>Funkcja nie dodaje odwołania do obiektu, bo nie zakłada, że ktoś go od razu użyje. W każdym miejscu, gdzie zostanie przypisany zwrócony obiekt, należy pamiętać o dodaniu odwołania oraz skasowaniu go, gdy obiekt przestanie być używany.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Nazwa bufora, po której można się będzie odwołać. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Wskaźnik na bufor z danym, które mają być przeniesione do bufora DirectXowego. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Rozmiar bufora. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Dodany bufor indeksów. Zwraca nullptr, jeżeli nie udało się stworzyć bufora. </dd></dl>

</div>
</div>
<a class="anchor" id="aee48f8c03cbc64d10072c49d498a33af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_resource_ptr.html">ResourcePtr</a>&lt; <a class="el" href="class_buffer_object.html">BufferObject</a> &gt; ResourceManager::CreateConstantsBuffer </td>
          <td>(</td>
          <td class="paramtype">const std::wstring &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_constant_buffer_init_data.html">ConstantBufferInitData</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates constant buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns buffer or nullptr if name already exists or buffer creation failed. </dd></dl>

</div>
</div>
<a class="anchor" id="aa98fb2ab5bab0a6c6c1f20f5edd0d8cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_resource_ptr.html">ResourcePtr</a>&lt; <a class="el" href="class_depth_stencil_state.html">DepthStencilState</a> &gt; ResourceManager::CreateDepthStencilState </td>
          <td>(</td>
          <td class="paramtype">const std::wstring &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_depth_stencil_info.html">DepthStencilInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Created <a class="el" href="class_depth_stencil_state.html">DepthStencilState</a> object. </p>
<dl class="section return"><dt>Returns</dt><dd>If object named name exist, returns nullptr. </dd></dl>

</div>
</div>
<a class="anchor" id="a00341729422730d9560abc9b7c6f63ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_resource_ptr.html">ResourcePtr</a>&lt; <a class="el" href="class_buffer_object.html">BufferObject</a> &gt; ResourceManager::CreateIndexBuffer </td>
          <td>(</td>
          <td class="paramtype">const std::wstring &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>elementSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>vertCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dodaje do ResourceManagera bufor indeksów. Jeżeli pod taką nazwą istnieje jakiś bufor, to zostanie zwrócony wskaźnik na niego. </p>
<dl class="section note"><dt>Note</dt><dd>Funkcja nie dodaje odwołania do obiektu, bo nie zakłada, że ktoś go od razu użyje. W każdym miejscu, gdzie zostanie przypisany zwrócony obiekt, należy pamiętać o dodaniu odwołania oraz skasowaniu go, gdy obiekt przestanie być używany.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Nazwa bufora, po której można się będzie odwołać. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Wskaźnik na bufor z danym, które mają być przeniesione do bufora DirectXowego. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elementSize</td><td>Rozmiar pojedynczego elementu w buforze. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertCount</td><td>Liczba wierzchołków/indeksów w buforze. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Dodany bufor indeksów. Zwraca nullptr, jeżeli nie udało się stworzyć bufora. </dd></dl>

</div>
</div>
<a class="anchor" id="af311328699c5d0d8862703a372dda584"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_resource_ptr.html">ResourcePtr</a>&lt; <a class="el" href="class_buffer_object.html">BufferObject</a> &gt; ResourceManager::CreateIndexBuffer </td>
          <td>(</td>
          <td class="paramtype">const std::wstring &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_index_buffer_init_data.html">IndexBufferInitData</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vreates index buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns buffer or nullptr if name already exists or buffer creation failed. </dd></dl>

</div>
</div>
<a class="anchor" id="aa318476801d2b5a1adbe130d6cd40817"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_resource_ptr.html">ResourcePtr</a>&lt; <a class="el" href="class_rasterizer_state.html">RasterizerState</a> &gt; ResourceManager::CreateRasterizerState </td>
          <td>(</td>
          <td class="paramtype">const std::wstring &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_rasterizer_state_info.html">RasterizerStateInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Created <a class="el" href="class_rasterizer_state.html" title="Rasterizer state and depth stencil state. ">RasterizerState</a> object. </p>
<dl class="section return"><dt>Returns</dt><dd>If object named name exist, returns nullptr. </dd></dl>

</div>
</div>
<a class="anchor" id="a4a00d9a302bf876e5da170ef13385e53"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_render_target_object.html">RenderTargetObject</a> * ResourceManager::CreateRenderTarget </td>
          <td>(</td>
          <td class="paramtype">const std::wstring &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_render_target_descriptor.html">RenderTargetDescriptor</a> &amp;&#160;</td>
          <td class="paramname"><em>renderTargetDescriptor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Znajduje Loader pasujący do pliku podanego w parametrze. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Ścieżka do pliku, dla której szukamy loadera. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Wskaźnik na odpowiedni loader lub nullptr, jeżeli nie znaleziono pasującego. Tworzy nowy render target.</dd></dl>
<p>Funkcja dodaje stworzony obiekt do tablicy m_renderTarget. Jeżeli tekstury bufora colorów, głębokości i stencilu nie są nullptrami, to i one są dodawane do tablicy m_texture.</p>
<p>Tekstury te mają nazwy jak render target + dodany jest człon</p><ul>
<li>::color</li>
<li>::depth</li>
<li>::stencil</li>
</ul>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000008">Todo:</a></b></dt><dd>Przy dodawaniu tekstur nie jest sprawdzane czy one już istnieją. Trzeba albo to sprawdzać, albo zapewnić np. jakąś polityką nazewnictwa, że w ten sposób nie nadpisujemy istniejącej tekstury.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Nazwa identyfikująca render target. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">renderTargetDescriptor</td><td>Deskryptor opisujący parametry render targetu. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zwraca stworzony obiekt lub nullptr w przypadku niepowodzenia. Jeżeli render target już istniał, to zwracany jest istniejący obiekt. </dd></dl>

</div>
</div>
<a class="anchor" id="afd23a950d995a07a6bcc5ca64bfc860d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_resource_ptr.html">ResourcePtr</a>&lt; <a class="el" href="class_buffer_object.html">BufferObject</a> &gt; ResourceManager::CreateVertexBuffer </td>
          <td>(</td>
          <td class="paramtype">const std::wstring &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>elementSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>vertCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dodaje do ResourceManagera bufor wierzchołków. Jeżeli pod taką nazwą istnieje jakiś bufor, to zostanie zwrócony wskaźnik na niego. </p>
<dl class="section note"><dt>Note</dt><dd>Funkcja nie dodaje odwołania do obiektu, bo nie zakłada, że ktoś go od razu użyje. W każdym miejscu, gdzie zostanie przypisany zwrócony obiekt, należy pamiętać o dodaniu odwołania oraz skasowaniu go, gdy obiekt przestanie być używany.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Nazwa bufora, po której można się będzie odwołać. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Wskaźnik na bufor z danym, które mają być przeniesione do bufora DirectXowego. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elementSize</td><td>Rozmiar pojedynczego elementu w buforze. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertCount</td><td>Liczba wierzchołków/indeksów w buforze. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Dodany bufor wierzchołków. Zwraca nullptr, jeżeli nie udało się stworzyć bufora. </dd></dl>

</div>
</div>
<a class="anchor" id="a851ebe7c00ed3837dbf83d4c195be1a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_resource_ptr.html">ResourcePtr</a>&lt; <a class="el" href="class_buffer_object.html">BufferObject</a> &gt; ResourceManager::CreateVertexBuffer </td>
          <td>(</td>
          <td class="paramtype">const std::wstring &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_vertex_buffer_init_data.html">VertexBufferInitData</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates vetex buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns buffer or nullptr if name already exists or buffer creation failed. </dd></dl>

</div>
</div>
<a class="anchor" id="a5fc1190ef3eaad6f3fcfd3bf5b9c16e6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_shader_input_layout.html">ShaderInputLayout</a>* ResourceManager::GetLayout </td>
          <td>(</td>
          <td class="paramtype">const std::wstring &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Zwraca layout o podanej nazwie. </p>

</div>
</div>
<a class="anchor" id="a2977707a7db0d1f8fde88af7dd929ed0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pixel_shader.html">PixelShader</a> * ResourceManager::LoadPixelShader </td>
          <td>(</td>
          <td class="paramtype">const std::wstring &amp;&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>shaderEntry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dodaje pixel shader do ResourceManagera. Jeżeli obiekt już istniał, to nie jest tworzony nowy. </p>
<dl class="section note"><dt>Note</dt><dd>Funkcja nie dodaje odwołania do obiektu, bo nie zakłada, że ktoś go od razu użyje. W każdym miejscu, gdzie zostanie przypisany zwrócony obiekt, należy pamiętać o dodaniu odwołania oraz skasowaniu go, gdy obiekt przestanie być używany.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fileName</td><td>Nazwa pliku, w którym znajduje się pixel shader. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">shaderEntry</td><td>Nazwa funkcji od której ma się zacząć wykonywanie shadera. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zwraca obiekt dodanego shadera. Zwraca nullptr, jeżeli shadera nie udało się skompilować. </dd></dl>

</div>
</div>
<a class="anchor" id="ad7dcc47c454a2fc26a8b749ad54383ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_texture_object.html">TextureObject</a> * ResourceManager::LoadTexture </td>
          <td>(</td>
          <td class="paramtype">const std::wstring &amp;&#160;</td>
          <td class="paramname"><em>fileName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dodaje teksturę do ModelManagera, jeżeli jeszcze nie istniała. </p>
<dl class="section note"><dt>Note</dt><dd>Funkcja nie dodaje odwołania do obiektu, bo nie zakłada, że ktoś go od razu użyje. W każdym miejscu, gdzie zostanie przypisany zwrócony obiekt, należy pamiętać o dodaniu odwołania oraz skasowaniu go, gdy obiekt przestanie być używany.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fileName</td><td>Ścieżka do tekstury</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zwraca wskaźnik na dodaną teksturę lub nullptr, jeżeli nie dało się wczytać. </dd></dl>

</div>
</div>
<a class="anchor" id="a371fca72b205d0b92476275862712cad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MemoryChunk ResourceManager::LoadTextureImpl </td>
          <td>(</td>
          <td class="paramtype">const filesystem::Path &amp;&#160;</td>
          <td class="paramname"><em>filePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_texture_info.html">TextureInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>texInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation of texture loading. </p>
<p>This is hack function. Resource manager have no texture loading function beacause it needs separate library for this. Derived classes will implement it, but in future this must change. <a class="el" href="class_resource_manager.html" title="Manager for low level resources. ">ResourceManager</a> must be fully operational class. Otherwise GUI won't load textures. </p>

</div>
</div>
<a class="anchor" id="a9a2453870e7f70bc30bb0adf894fb4bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_vertex_shader.html">VertexShader</a> * ResourceManager::LoadVertexShader </td>
          <td>(</td>
          <td class="paramtype">const std::wstring &amp;&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>shaderEntry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dodaje vertex shader do ResourceManagera. Jeżeli obiekt już istniał, to nie jest tworzony nowy. </p>
<dl class="section note"><dt>Note</dt><dd>Funkcja nie dodaje odwołania do obiektu, bo nie zakłada, że ktoś go od razu użyje. W każdym miejscu, gdzie zostanie przypisany zwrócony obiekt, należy pamiętać o dodaniu odwołania oraz skasowaniu go, gdy obiekt przestanie być używany.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fileName</td><td>Nazwa pliku, w którym znajduje się vertex shader. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">shaderEntry</td><td>Nazwa funkcji od której ma się zacząć wykonywanie shadera. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zwraca obiekt dodanego shadera. Zwraca nullptr, jeżeli shadera nie udało się skompilować. </dd></dl>

</div>
</div>
<a class="anchor" id="a19e57a77cdcdb9dd34412ec5de7bd8ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_vertex_shader.html">VertexShader</a> * ResourceManager::LoadVertexShader </td>
          <td>(</td>
          <td class="paramtype">const std::wstring &amp;&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>shaderEntry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_shader_input_layout.html">ShaderInputLayout</a> **&#160;</td>
          <td class="paramname"><em>layout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_input_layout_descriptor.html">InputLayoutDescriptor</a> *&#160;</td>
          <td class="paramname"><em>layoutDesc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dodaje vertex shader do ResourceManagera. Jeżeli obiekt już istniał, to nie jest tworzony nowy. Tworzy też layout wierzchołka związany z tym shaderem i zwraca go w zmiennej layout. </p>
<p>Jeżeli vertex shader wcześniej istniał, to stworzenie layoutu wymaga ponownego skompilowania shadera. Shader taki jest potem kasowany i nie zostaje zdublowany w ResourceManagerze, ale niepotrzebna praca zostaje włożona. Jest więc zadaniem programisty, żeby do takich rzeczy dochodziło jak najrzadziej.</p>
<dl class="section note"><dt>Note</dt><dd>Funkcja nie dodaje odwołania do obiektu, bo nie zakłada, że ktoś go od razu użyje. W każdym miejscu, gdzie zostanie przypisany zwrócony obiekt, należy pamiętać o dodaniu odwołania oraz skasowaniu go, gdy obiekt przestanie być używany.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fileName</td><td>Nazwa pliku, w którym znajduje się vertex shader. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">shaderEntry</td><td>Nazwa funkcji od której ma się zacząć wykonywanie shadera. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">layout</td><td>W zmiennej umieszczany jest wskaźnik na layout wierzchołka. Nawet jeżeli shader się nie skompilował, to pole może mieć wartość inną niż nullptr. Dzieje się tak wtedy, gdy layout istniał już wcześniej. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>Jeżeli vertex shader wcześniej istniał, to stworzenie layoutu wymaga ponownego skompilowania shadera. Shader taki jest potem kasowany i nie zostaje zdublowany w ResourceManagerze, ale niepotrzebna praca zostaje włożona. Jest więc zadaniem programisty, żeby do takich rzeczy dochodziło jak najrzadziej. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">layoutDesc</td><td>Deskryptor opisujacy tworzony layout. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zwraca obiekt dodanego shadera. Zwraca nullptr, jeżeli shadera nie udało się skompilować. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000010">Todo:</a></b></dt><dd>Ten kod to jakiś totalny shit. Jak komuś się będzie nudziło kiedyś (ha ha), to może niech poprawi. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>ResourceManager/<a class="el" href="_resource_manager_8h_source.html">ResourceManager.h</a></li>
<li>ResourceManager/<a class="el" href="_resource_manager_8cpp.html">ResourceManager.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Mar 4 2017 18:24:40 for Sleeping Wombat Graphic API by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
